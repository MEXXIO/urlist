Lifetime of an API request
==========================

API requests are handled by the *API server*, living in `motherbrain/api_server`.
Normally requests are routed either to our *python workers* (`motherbrain/workers`) or to 
our *golang stack*. We will cover this later.

Some kind of requests are handled by the API server. Those requests include:
- *authentication based on cookies*
- handling of signup through social providers (*facebook*, *google*)
- handling of login through social providers (*facebook*, *google*, *twitter*)
- handling of profile image and list cover

### Authentication of requests
Authentication is based on cookie and it work as following:

- No cookie      -> create an anonymous session 
- Valid cookie   -> authorize the request
- Invalid cookie -> return an error

A valid session is composed by three cookies:

- oauth_provider -> facebook,twitter,google or urlist
- oauth_user_id  -> user id
- oauth_token    -> a token generated by motherbrain backend

### Comunication between API Server and motherbrain workers

The API Server communicate with motherbrain workers using messages.
Messages are transported using *ZeroMQ* and encoded using JSON.
Encoding/decoding of messages is performed by `com.messages.MBMessage`,
sending is performed by `com.dispatchers`.

API Server connects to workers using `dispatchers.MBDispatcherCluster`, which
perform discovery of workers methods and can route message to different group
of workers.

Once a worker group is choosen by MBDispatcherCluster, ZeroMQ automatically perform
round robin and the message is dispatched using (usually) `MBAsyncDispatcher`. 

Since API Server ioloop is patched by ZMQ we can use it to schedule checking on a 
dispatch table, so everytime we get back a response from the workers, we invoke a callback
dealing with the results.

**Since at this point all the fetching work is handled by the golang stack, caching at this level
is discouraged has been removed**.

ZMQ supports queuing, so if for some reason the workers are no longer responding, messages got accumulated
in a buffer. When workers come up again messages are routed back to them. 

A diagram showing how tornado/zmq is working is available [here](https://github.com/urlist/urlist/blob/master/docs/api_server_async_flow.png)

### Anatomy of a message

A `MBMessage` is composed by the following fields:

- msg_id    -> ID used for routing
- action    -> will be translated to a function name on motherbrain worker
- target    -> in theory should contains information on target of action, like {'list_hash': 'foo'}
it get merged with payload
- payload   -> function keyword arguments
- context   -> extra information, usually from the API Server, most notably `current_user_id`

### Motherbrain worker function call

Once a message is received by a worker, the following actions are performed:

- Check if a method with name equal to message:action exists
- Create a function call, using message payload as keyword arguments and passing context as first positional argugment.
- Execute the function call, expecting either:
    - A dictionary with function result (can be empty)
    - A partially evaluated function
    - An exception

When result is a dictionary, payload field of response MBMessage is equal to result;
in case result is an exception, payload is exception string value;
in case result is a partially evaluated function, it will be evaluated.

### Motherbrain specific exceptions

##### OperationalError 
Caused by a wrong state of the system or wrong argument.
Examples: an invalid list hash is supplied 

##### ActionDoesNotExist
Lookup for a function with name `MBMessage.action` fails.

##### Unauthorized
Raised by `motherbrain.workers.decorators.secure_action` decorator.
`current_user_id` is not a valid user id or, user does not have enough privileges 
to execute the current action.
